&ACCESS RVP
&REL 1
&PARAM TEMPLATE = C:\KRC\Roboter\Template\vorgabe
&PARAM EDITMASK = *
DEF ethernet_streaming ( )
;FOLD INI
;FOLD BASISTECH INI
GLOBAL INTERRUPT DECL 3 WHEN $STOPMESS==TRUE DO IR_STOPM ( )
INTERRUPT ON 3
BAS (#INITMOV,0 )
;ENDFOLD (BASISTECH INI)
;ENDFOLD (INI)

;FOLD STARTPOSITION - BASE IS 0, TOOL IS 1, SPEED IS 45%, POSITION IS A1 5,A2 -90,A3 100,A4 5,A5 10,A6 -5,E1 0,E2 0,E3 0,E4 0
$BWDSTART = FALSE
PDAT_ACT = {VEL 45,ACC 100,APO_DIST 50}
FDAT_ACT = {TOOL_NO 1,BASE_NO 0,IPO_FRAME #BASE}
BAS (#PTP_PARAMS,45)
PTP  {A1 5, A2 -90, A3 100, A4 5, A5 10, A6 -5, E1 0, E2 0, E3 0, E4 0}
;ENDFOLD

;FOLD LIN SPEED IS 0.5 m/sec, INTERPOLATION SETTINGS IN FOLD
$VEL.CP=0.5
$ADVANCE=3
;ENDFOLD

RET=EKI_Init("RPiBinaryFixed")
RET=EKI_Init("RPiProgramServer")

;FOLD PREFILL ADVANCE RUN
LIN_REL {X 10}
LIN_REL {X 10}
LIN_REL {X 10}
LIN_REL {X 10}
;ENDFOLD

REQUEST_COMMANDS(CHUNK_SIZE / 2)
REQUEST_COMMANDS(CHUNK_SIZE)

WHILE LOOPING == TRUE
	RET = EKI_GetString("RPiProgramServer","BufferProgram",BYTES_INPUT[])
	CAST_FROM(BYTES_INPUT[],OFFSET,COMMAND,OUTPUT_COMMAND,R1,R2,R3,R4,R5,R6,C1,C2)
	RC = MOD(PC,10)
	
	SWITCH_COMMAND = COMMAND
	SWITCH SWITCH_COMMAND
		CASE CMD_START
			PC = 0
		CASE CMD_LIN
			RING_BUFFER_UPDATE()
			LIN RING_BUFFER[RC]
		CASE CMD_PTP_POS
			RING_BUFFER_UPDATE()
			PTP RING_BUFFER[RC]
		CASE CMD_PTP_AXIS
			RING_BUFFER_FORWARD()
			PTP RING_BUFFER[RC]
		CASE CMD_CIRC
			; NOT YET IMPLEMENTED
			i = 0
		CASE CMD_SPL
			; NOT YET IMPLEMENTED
			i = 0
		CASE CMD_HALT
			HALT 
		CASE CMD_WAIT 
			WAIT SEC R1
		CASE CMD_TOOL_COMMAND
			WAIT SEC 0
			TOOL_COMMAND5(OUTPUT_COMMAND,R1)
		CASE CMD_END
			LOOPING = FALSE
		DEFAULT
			HALT
	ENDSWITCH

	PC = PC + 1
	IF MOD(PC,CHUNK_SIZE) == 0 THEN
		REQUEST_COMMANDS(RET,CHUNK_SIZE)
	ENDIF
ENDWHILE

RET = EKI_Clear("RPiBinaryFixed")
RET = EKI_Clear("RPiProgramServer")
END

; === LOCAL SUBPROGRAMS AND FUNCTIONS ===

;FOLD RING_BUFFER_UPDATE : Fills the current ringbuffer position with data from network
DEF RING_BUFFER_UPDATE()
	RING_BUFFER[RC].x = R1
	RING_BUFFER[RC].y = R2
	RING_BUFFER[RC].z = R3
	RING_BUFFER[RC].a = R4
	RING_BUFFER[RC].b = R5
	RING_BUFFER[RC].c = R6
END 
;ENFOLD

;FOLD RING_BUFFER_FORWARD : Recomputes the current ringbuffer position using the forward kinematic solver
DEF RING_BUFFER_FORWARD()
	FORWARD_SOURCE.A1 = R1
	FORWARD_SOURCE.A2 = R2
	FORWARD_SOURCE.A3 = R3
	FORWARD_SOURCE.A4 = R4
	FORWARD_SOURCE.A5 = R5
	FORWARD_SOURCE.A6 = R6
	FORWARD_TARGET = FORWARD(FORWARD_TARGET,ERROR_CODE)
	RING_BUFFER[RC] = FORWARD_TARGET
END
;ENDFOLD

;FOLD REQUEST_COMMANDS : Strings a message to the program server asking for _AMOUNT more commands 
DEF REQUEST_COMMANDS(_AMOUNT:IN)
	INT _AMOUNT
	CAST_TO(BYTE_OUTPUT[],OFFSET,0,_AMOUNT)
	RET = EKI_Send("RPiProgramServer",BYTE_OUTPUT[])
END
;ENDFOLD

;FOLD INT:MOD : Integer modulo (%) operation on X and Y
DEFFCT INT MOD(X:IN,Y:IN)
DECL INT X,Y
RETURN(X-Y*(X/Y))
ENDFCT
;ENDFOLD

; === GLOBAL SUBPROGRAMS AND FUNCTIONS ===
;FOLD TOOL_COMMAND5 : Send a tool _COMMAND with one int of _DATA
GLOBAL DEF TOOL_COMMAND5(_COMMAND:IN,_DATA:IN)
CHAR _COMMAND
INT _DATA
WAIT SEC .1
RET = EKI_Open("RPiBinaryFixed")
CAST_TO(OUTPUT_BYTES[],OFFSET,_COMMAND,_DATA)
RET = EKI_Send("RPiBinaryFixed",OUTPUT_BYTES[])
IF _COMMAND == 0 THEN
	WAIT_FOR_RESPONSE()
ENDIF
RET = EKI_Close("RPiBinaryFixed")
END
;ENDFOLD

;FOLD WAIT_FOR_RESPONSE : wait for the tool controller to send a confirmation message (i.e. waiting for turntable to reach position)
GLOBAL DEF WAIT_FOR_RESPONSE()
CHAR _REC_MESSAGE
INT _REC_STATUS
_REC_MESSAGE = 0
_REC_STATUS = 0

WAIT FOR $FLAG[1]
RET=EKI_GetString("RPiBinaryFixed","Buffer5",BYTES_STATUS[])
CAST_FROM(BYTES_STATUS[],OFFSET,_REC_MESSAGE,_REC_STATUS)
; Do something if this is an error message here
$FLAG[1]=FALSE
END
